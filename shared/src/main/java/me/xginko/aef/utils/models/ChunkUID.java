package me.xginko.aef.utils.models;

import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.World;
import org.jetbrains.annotations.Nullable;

import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

public final class ChunkUID {

    private final UUID worldUID;
    private final int x, z;

    public static ChunkUID of(Chunk chunk) {
        return new ChunkUID(chunk.getWorld().getUID(), chunk.getX(), chunk.getZ());
    }

    private ChunkUID(UUID worldUID, int x, int z) {
        this.worldUID = worldUID;
        this.x = x;
        this.z = z;
    }

    public UUID getWorldUID() {
        return this.worldUID;
    }

    public int getX() {
        return this.x;
    }

    public int getZ() {
        return this.z;
    }

    public CompletableFuture<@Nullable Chunk> getChunkAsync(boolean gen) {
        World world = Bukkit.getWorld(worldUID);
        return world == null ? CompletableFuture.completedFuture(null) : world.getChunkAtAsync(x, z, gen);
    }

    @Override
    public String toString() {
        return "ChunkUID{" + "x=" + x + ", z=" + z + ", worldUID=" + worldUID + "}";
    }

    @Override
    public int hashCode() {
        return Objects.hash(this.worldUID, this.x, this.z);
    }

    @Override
    public boolean equals(Object obj) {
        if (null == obj || obj.getClass() != ChunkUID.class)
            return false;
        ChunkUID id = (ChunkUID)obj;
        return id.x == this.x && id.z == this.z && id.worldUID.equals(this.worldUID);
    }
}
