package me.xginko.aef.modules.lagpreventions.physics;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import me.xginko.aef.utils.models.BlockRegion2D;
import org.bukkit.Location;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

public abstract class PhysicsModule extends AEFModule implements Listener {

    protected final Cache<BlockRegion2D, RegionData> regions;
    protected final long pauseTimeMillis;
    protected final double checkRadius, pauseTPS, pauseMSPT;
    protected final boolean logIsEnabled;

    public PhysicsModule(String configPath) {
        super("lag-preventions.physics."+configPath);
        this.logIsEnabled = config.getBoolean(configPath + ".log", false);
        this.checkRadius = config.getDouble(configPath + ".check-radius-blocks", 1500.0,
                "The radius in blocks in which activity will be grouped together and measured.");
        this.pauseTimeMillis = config.getInt(configPath + ".pause-time-millis", 5000,
                "The time in milliseconds all related activity will be blocked if it exceeded\n" +
                        "the configured limit.");
        this.regions = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(
                config.getInt(configPath + ".data-keep-time-millis", 8000,
                        "The time in milliseconds before a region and its data will be expired\n" +
                                "if no activity has been detected.\n" +
                                "For proper functionality, needs to be at least as long as your pause time."))).build();
        this.pauseTPS = config.getDouble(configPath + ".pause-TPS", 16.0,
                "The TPS at which to cancel the physics entirely.");
        this.pauseMSPT = config.getDouble(configPath + ".pause-MSPT", 100.0,
                "The MSPT at which to cancel the physics entirely.");
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        regions.invalidateAll();
        regions.cleanUp();
    }

    protected @NotNull PhysicsModule.RegionData getRegionData(Location location) {
        for (Map.Entry<BlockRegion2D, RegionData> entry : regions.asMap().entrySet()) {
            if (entry.getKey().contains(location)) { // Get the first region that contains the location
                regions.put(entry.getKey(), entry.getValue()); // Reset timeout for region every time it's being accessed
                return entry.getValue();
            }
        }
        // Create and cache new region if no cached region was found encases the location
        return regions.get(BlockRegion2D.of(location.getWorld(), location.getX(), location.getZ(), checkRadius),
                blockRegion2D -> new RegionData());
    }

    protected void onLimitExceeded(Event event, Location location, int limit, RegionData regionData) {
        regionData.resumeTime.set(System.currentTimeMillis() + pauseTimeMillis);
        if (logIsEnabled) info("Cancelled " + event.getClass().getSimpleName() + " at " + LocationUtil.toString(location) +
                " because of too high activity within the configured timeframe: " + regionData.count + " (limit: " + limit + ")");
    }

    protected boolean isCriticallyLagging() {
        return AnarchyExploitFixes.getTickReporter().getTPS() <= pauseTPS || AnarchyExploitFixes.getTickReporter().getMSPT() >= pauseMSPT;
    }

    protected void onLagExceeded(Event event) {
        if (logIsEnabled) info("Cancelled " + event.getClass().getSimpleName() + " because server is lagging.");
    }

    protected static class RegionData {
        public final AtomicInteger count = new AtomicInteger(0);
        public final AtomicLong resumeTime = new AtomicLong(System.currentTimeMillis());
    }
}
