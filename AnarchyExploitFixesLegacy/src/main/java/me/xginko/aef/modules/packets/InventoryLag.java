package me.xginko.aef.modules.packets;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.netty.buffer.ByteBufHelper;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryOpenEvent;

import java.time.Duration;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

public class InventoryLag extends PacketModule implements Listener {

    private final Cache<UUID, PlayerData> playerDataCache;
    private final long rateLimitBytes, lockoutBytes, lockoutMillis;
    private final int screenOpenLimit, screenOpenDelay;
    private final boolean closeInventory, log;

    public InventoryLag() {
        super("patches.inventory-lag", PacketListenerPriority.HIGHEST);
        config.addComment(configPath + ".enable",
                "Checks if a player is requesting unusual amounts of traffic\n" +
                        "from the server using big ItemStacks.\n" +
                        "If a player exceeds the limit, they will be put on a cooldown,\n" +
                        "during which they will be very limited in terms of ItemStack or\n" +
                        "Inventory interactions.");
        this.log = config.getBoolean(configPath + ".log", false);
        this.closeInventory = config.getBoolean(configPath + ".close-open-inventory", true,
                "Whether to immediately close any open inventory of the player on limit exceed\n" +
                        "Side note: Closing has to be scheduled so it will take a bit if the server is heavily\n" +
                        "lagging.");
        this.playerDataCache = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(Math.max(1L,
                config.getLong(configPath + ".data-timeframe-millis", 20000,
                        "The time in millis in which to check if the player exceeded the limit.\n" +
                                "Needs to be at least as long as your cooldown millis.")))).build();
        this.rateLimitBytes = config.getLong(configPath + "rate-limit.bytesize-limit", 3584000,
                "The limit in bytes the server has sent the server in the form of ItemStacks,\n" +
                        "before the player will be put on a rate-limit.\n" +
                        "Should always be lower than lockout bytesize limit.");
        this.screenOpenDelay = config.getInt(configPath + "rate-limit.timeframe-millis", 1500,
                "The time in millis in which a player is allowed to open x amounts of windows\n" +
                        "but not more.");
        this.screenOpenLimit = config.getInt(configPath + "rate-limit.max-window-opens-per-timeframe", 2,
                "The amount of windows that can be opened during the timeframe-millis.");
        this.lockoutBytes = config.getLong(configPath + ".lockout.bytesize-limit", 5120000,
                "The upper limit in bytes a player is allowed to request from the server\n" +
                        "within the configured timeframe before he will be put on cooldown.\n" +
                        "During the cooldown, he will not be able to open any inventory screens\n" +
                        "or interact with items.");
        this.lockoutMillis = config.getLong(configPath + "lockout.duration-millis", 15000,
                "The time in milliseconds the player will have to wait before\n" +
                        "being able to open an inventory again after he exceeded the limit.");
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        PacketEvents.getAPI().getEventManager().registerListener(asAbstract);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        PacketEvents.getAPI().getEventManager().unregisterListener(asAbstract);
    }

    @Override
    @SuppressWarnings("DataFlowIssue")
    public void onPacketSend(PacketSendEvent event) {
        if (event.isCancelled()) return;

        if (event.getPacketType() == PacketType.Play.Server.OPEN_WINDOW) {
            PlayerData data = playerDataCache.get(event.getUser().getUUID(), PlayerData::new);

            if (data.screenNextAllowedOpen.get() > System.currentTimeMillis()) {
                event.setCancelled(true);
                if (log) info("Player '" + event.getUser().getName() + "' could not open screen because they are on cooldown.");
                return;
            }

            if (
                    data.servedSetSlotBytes.get() > rateLimitBytes
                            && data.servedSetSlotBytes.get() < lockoutBytes
                            && data.screenOpenCount.getAndIncrement() > screenOpenLimit
            ) {
                data.screenNextAllowedOpen.set(System.currentTimeMillis() + screenOpenDelay);
                if (log) info("Player '" + event.getUser().getName() + "' is now on ratelimit cooldown as they exceeded the set limit.");
                return;
            }

            return;
        }

        if (event.getPacketType() == PacketType.Play.Server.SET_SLOT) {
            PlayerData data = playerDataCache.get(event.getUser().getUUID(), PlayerData::new);

            if (data.screenNextAllowedOpen.get() > System.currentTimeMillis()) {
                event.setCancelled(true);
                return;
            }

            if (data.servedSetSlotBytes.addAndGet(ByteBufHelper.readableBytes(event.getByteBuf())) <= lockoutBytes) {
                return;
            }

            data.screenNextAllowedOpen.set(System.currentTimeMillis() + lockoutMillis);
            if (log) info("Player '" + event.getUser().getName() + "' is now on lockout cooldown as they exceeded the set limit.");

            if (closeInventory && event.getPlayer() != null) {
                plugin.getServer().getScheduler().runTask(plugin, ((Player) event.getPlayer())::closeInventory);
            }

            if (log) info("Player '" + event.getUser().getName() + "' is now on lockout cooldown for requesting more data " +
                    "from the server than the set limit.");
        }
    }

    @SuppressWarnings("DataFlowIssue")
    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onInventoryOpen(InventoryOpenEvent event) {
        PlayerData data = playerDataCache.get(event.getPlayer().getUniqueId(), PlayerData::new);

        if (data.screenNextAllowedOpen.get() > System.currentTimeMillis()) {
            event.setCancelled(true);
            return;
        }

        if (
                data.servedSetSlotBytes.get() > rateLimitBytes
                        && data.servedSetSlotBytes.get() < lockoutBytes
                        && data.screenOpenCount.getAndIncrement() > screenOpenLimit
        ) {
            data.screenNextAllowedOpen.set(System.currentTimeMillis() + screenOpenDelay);
        }
    }

    private static class PlayerData {

        public final UUID uuid;
        public final AtomicLong servedSetSlotBytes, screenNextAllowedOpen;
        public final AtomicInteger screenOpenCount;

        public PlayerData(UUID uuid) {
            this.uuid = uuid;
            this.servedSetSlotBytes = new AtomicLong(0L);
            this.screenNextAllowedOpen = new AtomicLong(0L);
            this.screenOpenCount = new AtomicInteger(0);
        }
    }
}
