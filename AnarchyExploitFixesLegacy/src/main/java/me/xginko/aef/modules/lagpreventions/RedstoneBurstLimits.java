package me.xginko.aef.modules.lagpreventions;

import com.cryptomorin.xseries.XMaterial;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import me.xginko.aef.utils.models.BlockRegion2D;
import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPistonExtendEvent;
import org.bukkit.event.block.BlockRedstoneEvent;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

public class RedstoneBurstLimits extends AEFModule implements Listener {

    private final Cache<BlockRegion2D, RedstoneData> regions;
    private final int regionSize, redstoneLimit, slimeLimit;
    private final boolean logIsEnabled;

    public RedstoneBurstLimits() {
        super("lag-preventions.redstone-burst-limiter");
        config.addComment(configPath + ".enable",
                "Concept by kumorio (6g6s.org).\n" +
                        "Watches redstone and piston activity within configurable, dynamically created regions.\n" +
                        "Slime limiter is used to fix EMP lag of the machine: https://www.youtube.com/watch?v=R_S8o4hngNI\n" +
                        "Demonstration of how this module works: https://www.youtube.com/watch?v=Rmlm-OVuBss");
        this.regionSize = config.getInt(configPath + ".region-radius-blocks", 1500,
                "Radius of the region in blocks. Redstone is limited by region.\n" +
                "It is recommended to be at least 1000.");
        this.regions = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(
                config.getInt(configPath + ".regiondata-keep-millis", 5000,
                        "The time after which the redstone burst counter will reset in milliseconds"))).build();
        this.redstoneLimit = config.getInt(configPath + ".redstone-limit.count", 5000,
                "Maximum number of redstone bursts in x milliseconds.");
        this.slimeLimit = config.getInt(configPath + ".slime-limit.count", 500,
                "Maximum number of movements for slime blocks in x milliseconds.");
        this.logIsEnabled = config.getBoolean(configPath + ".log", false);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    private @NotNull RedstoneData getRedstoneDataAt(Location location) {
        for (Map.Entry<BlockRegion2D, RedstoneData> entry : regions.asMap().entrySet()) {
            if (entry.getKey().contains(location)) {
                return entry.getValue();
            }
        }
        return regions.get(BlockRegion2D.of(location.getWorld(), location.getX(), location.getZ(), regionSize), k -> new RedstoneData());
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onBlockRedstone(BlockRedstoneEvent event) {
        Block block = event.getBlock();

        RedstoneData redstoneData = getRedstoneDataAt(block.getLocation());

        if (redstoneData.blockRedstoneEvents.incrementAndGet() > redstoneLimit) {
            event.setNewCurrent(0);
            if (logIsEnabled) info("Cancelled redstone at " + LocationUtil.toString(block.getLocation()) +
                    " because too much redstone events have fired within the configured timeframe: " +
                    redstoneData.blockRedstoneEvents + " redstone events (limit: " + redstoneLimit + ")");
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onBlockPistonExtend(BlockPistonExtendEvent event) {
        Block block = event.getBlock();

        RedstoneData redstoneData = getRedstoneDataAt(block.getLocation());

        for (Block movedBlock : event.getBlocks()) {
            if (movedBlock.getType() != XMaterial.SLIME_BLOCK.parseMaterial()) {
                continue;
            }

            if (redstoneData.pistonMovedSlimeBlocks.incrementAndGet() > slimeLimit) {
                event.setCancelled(true);
                if (logIsEnabled) info("Cancelled piston at " + LocationUtil.toString(block.getLocation()) +
                        " because too much slime blocks have been moved within the configured timeframe: " +
                        redstoneData.pistonMovedSlimeBlocks + " slime blocks (limit: " + slimeLimit + ")");
            }
        }
    }

    private static class RedstoneData {
        public final AtomicInteger blockRedstoneEvents = new AtomicInteger();
        public final AtomicInteger pistonMovedSlimeBlocks = new AtomicInteger();
    }
}
